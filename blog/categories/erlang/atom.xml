<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: erlang | coder karl]]></title>
  <link href="http://kjnilsson.github.io/blog/categories/erlang/atom.xml" rel="self"/>
  <link href="http://kjnilsson.github.io/"/>
  <updated>2015-08-08T22:24:13+01:00</updated>
  <id>http://kjnilsson.github.io/</id>
  <author>
    <name><![CDATA[Karl Nilsson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Not designing for Fault-tolerance]]></title>
    <link href="http://kjnilsson.github.io/blog/2015/08/08/not-designing-for-fault-tolerance/"/>
    <updated>2015-08-08T14:15:02+01:00</updated>
    <id>http://kjnilsson.github.io/blog/2015/08/08/not-designing-for-fault-tolerance</id>
    <content type="html"><![CDATA[<p>As an industry I think we (software developers) are pretty good at not designing for fault-tolerance, scalability and performance. And who can really blame us? These non functional &ldquo;requirements&rdquo; (NFRs) are hard to design for, make estimates and development costs rocket and mandate the introduction of new concepts to be learnt. Best avoided. We can&rsquo;t afford it.</p>

<p>You Ain&rsquo;t Gonna Need It (YAGNI).</p>

<p>Correct. I Ain&rsquo;t.</p>

<p><em>Or am I?</em></p>

<p>My first task as an application architect many years ago was to redesign a newly developed three-tier application so that it would at least perform adequately. It wasn&rsquo;t easy and the end result wasn&rsquo;t pretty (code-wise and architecturally) but at least it was mostly usable from a performance perspective. How can it be that it is somehow acceptable to write a new application that doesn&rsquo;t perform well enough to be used?</p>

<p>Why has there been so many occasions and conversations since that day about how to retro-fit scalability and fault-tolerance into services that lack them?</p>

<p>It is, of course, because not enough emphasis is put on these aspects at the design stage. Why is it then that they can so easily be put to one side, ignored and postponed? Why are these &ldquo;requirements&rdquo; so rarely emphasised up-front when the design decisions are made?</p>

<p><em>Time to market</em> is one very valid influence. There is little point making a reliable system months after your competitors have already mopped up the bulk of the customers.</p>

<p><em>Domain focus</em> is another which I am not going to argue against. It is sensible to try to provide a good solution to the problem domain first at the expense of NFRs. (First make it right, then make it fast/tolerant/scalable).</p>

<p>Our tendency to ignore fault-tolerance, scalability and performance (FTSP) affects our technology choices. If fault-tolerance is likely to become important in the future would we really choose .NET, ruby or even go as our runtime/language of choice? I doubt it, I&rsquo;ve written systems that have these properties in .NET but it was hard, time-consuming, error-prone. It always felt like there should be a better way. Something that would help me a bit more.</p>

<p>Perhaps it is actually time to start using that that thing that everyone talks about but nobody really uses? That strange runtime with it&rsquo;s odd language. That <em>Erlang</em> thing.</p>

<p>Naturally using erlang (or rather the erlang runtime, the BEAM) won&rsquo;t automatically make anything scalable, fault-tolerant or performant, let&rsquo;s make that really clear. But maybe targeting this runtime will allow us to more sensibly design our application such that we can more easily retro-fit fault-tolerance without a big rewrite. Perhaps having a sensible isolation model, built-in distribution and well known design patterns for fault-tolerance will put us onto a path of likely success once these requirements suddenly float to the top of the list?</p>

<p>If we are going to continue ignoring fault-tolerance, scalability and performance let&rsquo;s at least do it in a sensible manner.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Agents Fail]]></title>
    <link href="http://kjnilsson.github.io/blog/2013/12/16/how-agents-fail/"/>
    <updated>2013-12-16T10:00:27+00:00</updated>
    <id>http://kjnilsson.github.io/blog/2013/12/16/how-agents-fail</id>
    <content type="html"><![CDATA[<p>Agents (<code>MailboxProcessor</code> in fsharp) can be incredibly useful. They allow you to control concurrency and access to shared state in a simple and safe manner, something that is surprisingly hard in languages without similar abstractions. Having spent the last 6 months writing a fairly decently sized, distributed business application in fsharp it proved natural for us to make frequent use of agents almost to the extent that <em>&lsquo;just add another agent&rsquo;</em> often is suggested as the fix for most problems that we encounter.
Naturally this approach is not without problems. Fsharp agents do not have any default strategies of how to work with multiple agents or any built-in strategies for dealing with agent failures. All these aspects need to be handled in code and this blog entry aims to explore a couple of options for dealing with unhandled exceptions in agents.</p>

<p>So how <em>do</em> agents fail? Silently, it turns out. When an unhandled exception occurs in the body of an agent the exception is not allowed to escape the agent unless you subscribe to the &lsquo;Error&rsquo; event. This may seem an unusual default to have for developers used to traditional .NET/Java exception handling but if you look at other languages which may have inspired this model (e.g. <a href="http://www.erlang.org/doc/reference_manual/processes.html">erlang</a>) it actually makes perfect sense. An agent (or <em>process</em> in erlang) is an isolated unit of computation such that the failure of one should not affect other agents unless explicitly linked together to form a <em>supervision tree</em>. The supervision tree is a key pattern that is used to build fault tolerant application in Erlang.
Fsharp doesn&rsquo;t have an api for creating supervision trees but does provide all the components needed to do so (at least for in-process).</p>

<p>```fsharp
let spawn () =</p>

<pre><code>MailboxProcessor.Start (fun inbox -&gt;
    let rec loop state =
        async {
            let! msg = inbox.Receive ()
            if msg = 42 then failwith "can't catch me" 
            else
                return! loop (state + msg) }
    loop 0)
</code></pre>

<p>```</p>

<h3>Catch it!</h3>

<p>So an agent that throws an unobserved exception is effectively rendered useless. New messages will be accepted but never processed and although the agent handler has failed they will still be added to the internal, unbounded mailbox queue potentially causing an eventually fatal memory leak.</p>

<p>This is often undesirable, so what can we do to address it? The simplest possible way to simulate &lsquo;classic&rsquo; .NET exception handling behaviour is to re-raise any exceptions on to the thread the agent was created on and rely on some other exception handler to catch it.</p>

<p>```fsharp
let agent = MailboxProcessor.Start()
agent.Errors.Add raise</p>

<p>```</p>

<p>But in many cases we want more detailed control over the strategies we employ to recover from such exceptions. We have already mentioned the solution above: <em>supervision trees</em>.</p>

<h3>Feeling watched&hellip;</h3>

<p>Below follows an example on how to implement a simple supervisor that keeps a registry of <em>id</em> to <em>agent</em> and relaunches any monitored agents that fail. Note that the <code>spawnLink</code> functions add the error handler before starting the agent. This is sensible in the rare occurrence that the agent will fail before the error handler is added. Erlang has a similar <a href="http://www.erlang.org/doc/man/erlang.html#spawn_link-1">function</a> for exactly this reason.</p>

<p>Supervisors allow you to implement sensible restart strategies for failed agents.</p>

<p>```fsharp
module Worker =</p>

<pre><code>open System

type WorkerProtocol = 
    | DoWork
    | Exit

let spawnLink link = 
    let mb = new MailboxProcessor&lt;WorkerProtocol&gt;(fun inbox -&gt;
        let rec loop c = async {
            let! msg = inbox.Receive ()
            match msg with
            | DoWork -&gt;
                printfn "working..."
                do! Async.Sleep 250
                if c &gt; 4 then failwith "oops"
                return! loop (c + 1)
            | Exit -&gt;
                () }
        loop 0)
    mb.Error.Add link
    mb.Start()
    mb
</code></pre>

<p>module Supervisor =</p>

<pre><code>open System

type SuperProtocol =
    | ChildFaulted of Guid

let dispose (o : obj) =
    match o with
    | :? IDisposable as d -&gt; d.Dispose()
    | _ -&gt; ()

// this is also a spawnLink as other agents could supervise other supervisors
let spawnLink link =
    let agent = new MailboxProcessor&lt;SuperProtocol&gt; (fun inbox -&gt;
        // error handler that sends a message to the supervisor's inbox that 
        // a child agent has failed
        // In this instane we don't care which exception was thrown
        let errorHandler childId = fun _ -&gt; inbox.Post (ChildFaulted childId)
        let rec loop registry = 
            async {
                let! msg = inbox.TryReceive 1000
                match msg with
                | Some (ChildFaulted childId) -&gt;
                    printfn "child faulted %A" childId
                    dispose (Map.find childId registry)
                    printfn "re-launching child %A" childId
                    let registry = 
                        Map.add childId (Worker.spawnLink (errorHandler childId)) registry
                    return! loop registry 
                | None -&gt;
                    printfn "asking workers to do work"
                    registry |&gt; Map.iter (fun k v -&gt; v.Post (Worker.WorkerProtocol.DoWork))
                    return! loop registry }

        // start the supervisor by creating 5 worker child agents
        [0..4]
        |&gt; List.map (fun _ -&gt; Guid.NewGuid()) 
        |&gt; List.map (fun childId -&gt; childId, Worker.spawnLink (errorHandler childId)) 
        |&gt; Map.ofList
        |&gt; loop)
    agent.Error.Add link
    agent.Start()
    agent 
</code></pre>

<p>```</p>

<p>Programming with agents in fsharp is both fun and enabling but there are patterns that will make the overall experience  better in the long run if you get right early. In potential future entries I&rsquo;d like to cover my experience regarding flow control and distribution and any other interesting aspects I may come across.</p>
]]></content>
  </entry>
  
</feed>
